2 Создать несколько объектов User и руками рассчитать сколько он будет занимать памяти.

 Можно отслеживать размер свободной памяти перед созданием и после для созданного объекта.
   Брать разницу между размером общей памяти и размером свободной памяти.
    (rt.totalMemory() - rt.freeMemory()) / cnt;
  И оценивать средний размер на основе многих итераций.  Но это очень неточный метод.
  Но по факту ничего оценить так не получилось.

  Лучше использовать библиотеки.
  Например com.carrotsearch.sizeof.RamUsageEstimator.sizeOf
  или  java.lang.instrumentation package

    Размер объекта зависит от размера его полей.
     User("test Next user") занимает 72b

3 Нужно найти информацию. Сколько памяти занимает пустой объект без полей.

    Размер Объекта без полей 16 байт. Все это размер заголовка.

4 Добиться состояния, когда виртуальная машины вызывает сборщик мусора самостоятельно. За счет ключей xmx.

    Добился, выставив 14мб.
    При работе цикла периодически вызывается сборщик.
    При установке 4 мб программа даже не запустиласть, выдав OutOfMemoryError: Java heap space.
    Мусорщик не успел решить проблемы, как память закончилась.





Используя разные ключи запуска виртуальной машины установить различные виды сборщика мусора.
6. Оценить поведения срабатывания различных типов сборщиков мусора для программы из первого урока данной модуля.

Serial запускался чаще всех, даже когда памяти вроде хватало.
Parallel ставится jvm по умолчанию если есть несколько ядер. Запустился когда свободная память опустилась до 40%.
Восстановил свободную память до 60%
 CMS GC тоже стартовал где то на 40%. И периодически запускался после.  Каких то особых закономерностей я увидел.
G1 стартовал позже всех, позволив памяти просесть где то до 35 %


 Ни один из сборщиков не мог в процессе работы цикла восстановить близко к 100%, где до 70 очищал.



7. Как вы считаете какой из сборщиков мусора подойдет наиболее оптимально для приложения заявок из второго модуля?

Приложению не требуется большой размер кучи для работы (Oracle указывает условную границу 100 МБ),
оно не очень чувствительно к коротким остановкам так что можно взять Serial.
Но наличии нескольких процессорных ядер выигрыш в скорости будет при использовании Parallel.


8. Какой тип сборщика будет оптимален для серверного приложения?

Подойдет Concurrent Mark Sweep (CMS).  При работе с очень большими объемами данных на многопроцессорных серверах
стоит выбрать Garbage-First (G1), как более современный сборщик.








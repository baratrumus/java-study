2 Создать несколько объектов User и руками рассчитать сколько он будет занимать памяти.

 Можно отслеживать размер свободной памяти перед созданием и после для созданного объекта.
   Брать разницу между размером общей памяти и размером свободной памяти.
    (rt.totalMemory() - rt.freeMemory()) / cnt;
  И оценивать средний размер на основе многих итераций.  Но это очень неточный метод.
  Но по факту ничего оценить так не получилось.

  Лучше использовать библиотеки.
  Например com.carrotsearch.sizeof.RamUsageEstimator.sizeOf
  или  java.lang.instrumentation package

    Размер объекта зависит от размера его полей.
     User("test Next user") занимает 72b

3 Нужно найти информацию. Сколько памяти занимает пустой объект без полей.

    Размер Объекта без полей 16 байт. Все это размер заголовка.

4 Добиться состояния, когда виртуальная машины вызывает сборщик мусора самостоятельно. За счет ключей xmx.

    Добился, выставив 14мб.
    При работе цикла периодически вызывается сборщик.
    При установке 4 мб программа даже не запустиласть, выдав OutOfMemoryError: Java heap space.
    Мусорщик не успел решить проблемы, как память закончилась.





5. Используя разные ключи запуска виртуальной машины установить различные виды сборщика мусора.

6. Оценить поведения срабатывания различных типов сборщиков мусора для программы из первого урока данной модуля.

7. Как вы считаете какой из сборщиков мусора подойдет наиболее оптимально для приложения заявок из второго модуля?
При наличии нескольких процессорных ядер выигрыш в скорости будет практически во всех приложениях.


8. Какой тип сборщика будет оптимален для серверного приложения?









